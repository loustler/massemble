# OS

## Process
- 현재 실행중인 Computer Program의 Instance
- OS에 의해서 관리가 되고 OS가 Processor에 할당해주면 Processor가 Computer Program을 실행
- 1개 이상의 Thread를 가짐
- 각 process는 고유한 system resource를 OS로부터 할당받고 서로의 resource에 접근할 수 없음

## Thread
- Process의 구성요소로 OS Scheduler에 의해 도긻적으로 관리될 수 있는 가장 작은 단위의 프로그래밍 명령 시퀀스
- Process와 달리 같은 Process에 있는 Thread들은 서로 같은 리소스를 공유하며 접근할 수 있음(Stack 제외)

## MultiThread의 장점
1. Multi Process에 비해 적은 Context Switching 비용
1. Process는 서로 IPC 등을 통해 통신해야 하므로 같은 리소스를 공유하는 Thread에 비해 커뮤니케이션 비용이 더 큼

## Synchronous, Asynchronous, Blocking, Non-Blocking
1. Synchronous
1. Asynchronous
1. Blocking
1. Non-Blocking

Blocking <-> Non-Blocking은 말 그대로 함수를 호출하고 난 다음에 block이 되느냐 되지 않느냐 즉 함수가 바로 리턴되느냐의 차이다.

Synchronous <-> Asynchronous 쉽게 Callback의 유/무에 나뉜다고 생각하면 됨

Callback을 이용하면 callback이 불려졌을 때 실행될 코드만 주고 나면 신경쓰지 않고 다른 작업을 이어서 할 수 있음

보통 Non-Blocking - Asynchronous 를 같이 사용하는게 익숙하고 Blocking - Synchronous 를 같이 사용하는게 익숙하다.

## 자원 동기화 문제 해결
1. 뮤텍스(Mutex)
   - 프로세스가 공유자원을 사용하고 있을 때 다른 공유자원이 접근하지 못하게 함
   - 1개의 Key를 가지고 한 번에 1개의 프로세스만 접근할 수 있게 함
   - Key를 가지고 있지 않은 프로세스는 키를 얻을 때 까지 대기해야 됨
   - 조건
        1. 두 프로세스는 동시에 공유 자원에 진입할 수 없음
        1. 프로세스의 속도나 수에 영향 X
        1. 공유자원을 사용하는 프로세스만 다른 프로세스를 차단 가능
        1. 프로세스가 공유 자원을 사용하려고 하면 너무 오래기다려선 안됨
1. 세마포어(Semaphore)
    - Atomic 연산인 `wait()`와 `signal()`로 접근이 가능
    - 세마포어 정수값 `S`를 이용
    - 카운팅 세마포어
        - 사용가능한 자원의 개수의 값으로 `S`가 초기화 됨
        - `wait()`는 세마포어값을 감소, `signal()`은 세마포어값을 증가시킴
        - `wait()`은 자원에 접근하려고 할 때, `signal()`은 자원을 방출할 때
    - 이진 세마포어
        - 0 과 1의 값만 가능
        - `S`가 1로 초기화됨
    - 바쁜 대기(busy wating)을 요구(계속 대기하면서 자원 접근 요청)
    - 대기큐를 가진 세마포어를 구현할 때 deadlock이 발생할 수 있음
1. 모니터(Monitor)
   - Semaphore에서 발생할 수 있는 타이밍 문제를 해결하고자 함(재현이 쉽지 않음)
   - 프로세스들이 모니터의 프로시저를 호출하여 모니터안에 진입하여 데이터에 접근함
   - 다른 프로세스가 이미 모니터안에 진입했다면 외부 준비 큐에서 대기해야 됨
   - `condition`을 제공
        - 조건이 맞지 않는다면 `wait()`를 호출하여 실행 중이던 프로세스 A가 내부 준비큐로 들어가게 되고, 새로운 프로세스 B가 모니터 안으로 들어옴
        - 프로세스 B가 `signal()`을 호출하면 준비 큐애서 중단되어 대기 중이던 프로세스 A가 들어와 작업을 재개
   - Java가 사용함
        - `Object#wait()`: 모니터 내부의 WaitSet에 들어가 중단된 상태로 대기
        - `Object#notify()`, `Object#notifyAll()`: 모니터 내부에 있는 WaitSet에 있는 프로세스 중 하나를 실행상태로 만듦
        - 외부 준비큐: Entry Set
        - 모니터 내부 대기큐: Wait Set

### 뮤텍스(Mutex) vs 세마포(Semaphore)
||Mutex|Semaphore|
|---|---|---|
|매커니즘|잠금 매커니즘|시그널링 매커니즘|
|값|Object|정수 변수|
|접근|여러 프로세스가 단일 리소스에 액세스할 수 있지만 동시에 수행 불가|여러 프로세스가 여러 유한한 자원에 액세스 가능|
|값의 변경|Lock은 획득한 프로세스에 의해서만 해제|자원을 얻거나 해제하는 프로세스에 의해 변경|
|분류|X|카운팅, 이진|
|자원이 모두 사용중일 때 접근|Lock이 걸려있으면 Lock의 소유 프로세스가 해제할 때까지 다른 프로세스들은 대기(busy wating)|모든 리소스가 사용중이면 리소스를 요청하는 프로세스는 `wait()` 작업 수행. 유한한 자원이 발생했을 때 접근|

## 메모리
### 내부 단편화, 외부 단편화
1. 내부 단편화
   - 교체된 페이지의 크기가 할당된 공간의 크기보다 작은 경우 발생
   - 저장 공간의 낭비
1. 외부 단편화
   - 메모리가 할당되고 해체될 때 발생하는 작은 공간이 생기게 되는데, 총 공간은 충분하지만 교체된 페이지의 크기가 할당된 공간의 크기보다 클 때 발생
   - 공간 중 일부가 사용 못하게 되는 상황
   - 중간 중간에 비는 공간으로 인해 공간을 할당할 수 있음에도 할당하지 못하는 현상

### 단편화 해결기법
1. 페이징(Paging)
   - 페이지가 연속적인 물리 메모리 공간에 들어가야하는 제약을 해결하기 위한 방법
   - 가상 메모리는 Page, 물리 메모리는 Frame라는 고정형태의 블록으로 나눠서 Page Table과 매핑을 통해 바인딩함
   - 외부 단편화를 해결할 수 있으며, 사이즈를 작게하면 내부 단편화도 해결할 수 있으나 page mapping 과정이 증가함(trade-off)
   - Frame과 Page 모두를 관리하기 위해 Frame Table, Paging Table이 존재하며 OS가 각 프로세스마다 할당함
1. 세그먼테이션(Segmentation)
   - 서로 다른 크기의 블록으로 나누는 방법(동적)
   - 내부 단편화 해결 가능, 외부 단편화는 존재(기존에 사용하던 메모리를 해제하면 생길 수 있음)

### 가상 메모리
1. 가상 메모리
   - 프로그램 실행에 필요한 메모리 전체를 RAM에서 할당받는 것이 아니라 최소한의 메모리만 RAM에서 할당받고 나머지는 디스크에 공간을 만들어 저장
   - 
1. 페이지 폴트
   - 가상 메모리를 사용할 때 물리 메모리인 RAM과 가상 메모리인 DISK에 나누어서 저장하는데, 이 때 필요로 하는 페이지가 물리 메모리에 없을 때를 일컫음
1. 요구 페이징
   - 페이지 폴트가 발생하면 OS가 가상 메모리에서 해당 페이지를 찾아서 물리 메모리의 불필요 페이지와 교체를 요구함
   - 이 때 모든 스레드는 멈춰 대기함

### 페이지 교체 알고리즘
1. FIFO(First In First Out)
   - 가장 오래된 페이지를 교체
1. LRU(Least Recently Used)
   - 가장 오랫동안 사용하지 않은 것을 교체
1. LFU(Least Frequently Used)
   - 가장 사용 빈도가 적은 것을 교체
   - 교체 대상이 여러 개일경우 LRU를 사용
1. MFU(Most Frequently Used)
   - 가장 사용 빈도가 많은 것을 교체

